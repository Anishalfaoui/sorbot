# Authors 
- Aksil SADI
- Anis HALFAOUI
- Merouane BOUAFIA
- Mickael VILAYVANH

# Sorbot Technical Specification

Sorbot is a distributed algorithmic trading system consisting of a Java/Spring Boot backend, a React frontend, and a Python-based machine learning inference engine.

[Figma](https://www.figma.com/make/H0x4DruIOw6sZ7Qwu1e2d3/5-Page-Crypto-Trading-Website?p=f&t=ezv0vYgc4ttAnvFq-0)

---

## 1. Functionalities

### 1.1 AI-Powered Trading Signals
- Real-time **BUY / SELL / HOLD** predictions generated by an XGBoost classifier.
- Confidence score (0â€“1) attached to every signal for risk-aware decision making.
- Technical indicator computation (RSI, MACD, Bollinger Bands, ATR) as input features.

### 1.2 Automated Trade Execution
- Scheduled bot that polls the AI Engine every 60 seconds for fresh predictions.
- Automatic order placement based on signal direction and user-defined risk threshold.
- Full trade history logging with execution price, quantity, and timestamp.

### 1.3 Portfolio Management
- Track holdings per symbol with average entry price and quantity.
- Real-time portfolio valuation updated via market data.

### 1.4 Interactive Dashboard
- Live price charts with technical indicator overlays (Recharts).
- Market depth view showing current holdings at a glance.
- Order book displaying historical transactions.
- Auto-refreshing data via React Query polling every 2 seconds.

### 1.5 Bot Configuration
- Per-user bot settings: toggle bot on/off, adjust risk threshold.
- CRUD interface for managing trading preferences from the frontend.

### 1.6 User Authentication & Authorization
- Secure registration and login with hashed passwords.
- Role-based access control managed by Spring Security.

### 1.7 Multi-Symbol Support
- Query predictions for any supported cryptocurrency or stock symbol.
- Independent signal generation per symbol via the endpoint.

### 1.8 Containerized Deployment
- One-command startup with Docker Compose (AI Engine, Backend, Frontend, PostgreSQL).
- Environment-variable-driven configuration for seamless dev/prod switching.


## 2. System Architecture

The system follows a decoupled microservices pattern. Communication between the Application layer and the Machine Learning layer is handled via RESTful API calls to ensure language-agnostic development.

### 2.1 Service Interaction (API Contract)
The Application layer polls the AI Engine via the following specification:

**Endpoint:** `GET /predict?symbol={string}`

**Response Schema:**
```json
{
  "symbol": "string",
  "direction": "BUY | SELL | HOLD",
  "confidence": "float [0.0, 1.0]",
  "current_price": "float",
  "timestamp": "ISO-8601",
  "indicators": {
    "rsi": "float",
    "macd": "string"
  }
}

```

---

## 3. Component Specifications

### 3.1 Backend Application (Java/Spring Boot)

* **Persistence Layer:** PostgreSQL/H2 Database.
* `Users`: id (PK), username, password_hash, role.
* `Portfolio`: user_id (FK), symbol, quantity, average_price.
* `TradeHistory`: id (PK), symbol, action, execution_price, quantity, timestamp.
* `BotSettings`: user_id (FK), risk_threshold, is_active.


* **Execution Engine:** Implementation of `@Scheduled(fixedRate = 60000)` to trigger periodic inference requests.
* **Service Layer:** Interface-driven design for `PredictionService` allowing for a `MockPredictionServiceImpl` during development and a `RestPredictionServiceImpl` for production.

### 3.2 Frontend Dashboard (React)

* **State Management:** React Query for asynchronous data fetching and automatic polling every 2000ms.
* **Visualizations:** Recharts library for time-series price data and technical indicator overlays.
* **Components:**
* `MarketDepth`: Tabular representation of current holdings.
* `OrderBook`: Log of historical transactions.
* `ConfigurationInterface`: CRUD operations for `BotSettings`.



### 3.3 AI Engine (Python/FastAPI)

* **Data Ingestion:** Integration with `yfinance` or `ccxt` for OHLCV data retrieval.
* **Feature Engineering:** Calculation of technical indicators (RSI, Bollinger Bands, ATR) using `pandas` or `TA-Lib`.
* **Inference Model:** XGBoost (Extreme Gradient Boosting) classifier.
* Model persistence via `model.json` or `pickle`.


* **API Layer:** FastAPI implementation to serve model predictions with sub-second latency.

---

## 4. Infrastructure and Deployment

The system is designed for containerized deployment using Docker Compose to manage environment variables and network links between services.

```yaml
version: '3.8'
services:
  ai-engine:
    build: ./ai-engine
    ports:
      - "8000:8000"
  backend-api:
    build: ./backend-api
    ports:
      - "8080:8080"
    environment:
      - AI_SERVICE_URL=http://ai-engine:8000
  frontend-client:
    build: ./frontend-client
    ports:
      - "3000:3000"

```

---

## 5. Development Roadmap

### Phase 1: Environment Setup

* Initialize Spring Boot project with JPA and Security dependencies.
* Establish Python virtual environment and FastAPI skeleton.

### Phase 2: Implementation

* **App Team:** Define JPA entities and implement the trade execution logic loop.
* **AI Team:** Implement data pipeline and baseline XGBoost training script.

### Phase 3: Integration

* Replace Mock services in Java with `RestTemplate` or `WebClient` calls to the Python API.
* Finalize React dashboard components for real-time telemetry.

---
